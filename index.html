<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JTA</title>
    <link rel="stylesheet" href="main.css">
    <script defer src="alpine3.14.9.js"></script>
</head>
<body x-data="main">
    <div class="no-print">
        <div>
            <label>
                Word list (separated by commas or linebreaks)
                <br>
                <textarea placeholder="Add words here..." style="width: 99%;" :rows="Math.max(listLength,2)" x-model="wordBox" @input="changeWordBox()"></textarea>
            </label>
        </div>
        <br>
        <template x-if="dupes.length > 0">
            <div class="dupewarn">
                The following words have matching sets of letters. Anagram methods will not be able to differentiate them:
                <ul>
                    <template x-for="dupelist in dupes">
                        <li>
                            <span x-text="dupelist.join(', ')"></span>
                        </li>
                    </template>
                </ul>
            </div>
        </template>
        <label>
            <input type="checkbox" x-model="hideBad" @change="calcSums(startNode, true)">
            Hide letters that will increase the maximum number of guesses
        </label>
        <br>
        <label>
            <input type="checkbox" x-model="isVertical">
            Vertical
        </label>
        <br>
        <label>
            <input type="radio" x-model="nosFirst" value="true" @input="recalcTree()"> "No" is <span x-show="isVertical">up</span><span x-show="!isVertical">left</span>
        </label>
        <br>
        <label>
            <input type="radio" x-model="nosFirst" value="" @input="recalcTree()"> "Yes" is <span x-show="isVertical">up</span><span x-show="!isVertical">left</span>
        </label>
        <br>
        <br>
    </div>
    <div x-show="isVertical">
        <div class="gridwrap" :style="'grid-template-rows: ' + 'auto '.repeat(startNode.leaves) + ';grid-template-columns: ' + 'auto '.repeat(levelCount) + ';'">
            <template x-for="node in gridList">
                <div :class="'yaybox ' + node.css + (node.chosenLetter ? ' clicky gridclicky' : '')" :style="'grid-area: span ' + node.leaves + ' / span ' + node.breadth + ';'" @click="deselectLetter(node)">
                    <div x-show="node.chosenLetter">
                        <span x-text="node.chosenLetter"></span>
                    </div>
                    <span x-show="!node.chosenLetter && node.words.length <= 1" x-text="node.words[0]" class="targetword"></span>
                    <table x-show="!node.chosenLetter && node.words.length > 1" class="picker" x-data="{ hindex: -1 }">
                        <thead>
                        <tr>
                            <template x-if="!node.deadEnd">
                                <th></th>
                            </template>
                            <template x-for="(letter, index) in letters">
                                <th :class="node.colors[index] + (hindex == index ? ' hovering' : '')" class="pickercol" @click.stop="selectLetter(node, index)" @mouseenter="hindex = index" @mouseleave="hindex = -1">
                                    <span x-text="letter"></span>
                                    <br>
                                    <span class="pickersum" x-text="node.sums[index]"></span>
                                </th>
                            </template>
                        </tr>
                        </thead>
                        <tbody>
                        <template x-for="(word, index) in node.words">
                            <tr x-show="word != ''">
                                <td class="wordhere" x-text="word"></td>
                                <template x-for="(exists, index) in node.matrix[index]">
                                    <td class="pickercol" :class=" node.colors[index] + (hindex == index ? ' hovering' : '')" @click.stop="selectLetter(node, index)" @mouseenter="hindex = index" @mouseleave="hindex = -1">
                                        <template x-if="exists"><span>X</span></template>
                                    </td>
                                </template>
                                <template x-if="node.deadEnd && index === 0">
                                    <td :rowspan="node.words.length" style="vertical-align: middle;background-color: #800;color: #fff;">
                                        <strong>DEAD END</strong>
                                    </td>
                                </template>
                            </tr>
                        </template>
                        </tbody>
                    </table>
                </div>
            </template>
        </div>
    </div>
    <table x-show="!isVertical">
        <tbody>
            <template x-for="level in levels">
                <tr>
                    <template x-for="node in level">
                        <td :colspan="node.leaves" :rowspan="node.breadth" :class="node.css">
                            <div x-show="node.chosenLetter" x-text="node.chosenLetter" @click="deselectLetter(node)" class="clicky"></div>
                            <span x-show="!node.chosenLetter && node.words.length <= 1" x-text="node.words[0]" class="targetword"></span>
                            <table x-show="!node.chosenLetter && node.words.length > 1" class="picker" x-data="{ hindex: -1 }">
                                <thead>
                                <tr>
                                    <template x-if="!node.deadEnd">
                                        <th></th>
                                    </template>
                                    <template x-for="(letter, index) in letters">
                                        <th :class="node.colors[index] + (hindex == index ? ' hovering' : '')" class="pickercol" @click.stop="selectLetter(node, index)" @mouseenter="hindex = index" @mouseleave="hindex = -1">
                                            <span x-text="letter"></span>
                                            <br>
                                            <span class="pickersum" x-text="node.sums[index]"></span>
                                        </th>
                                    </template>
                                </tr>
                                </thead>
                                <tbody>
                                <template x-for="(word, index) in node.words">
                                    <tr x-show="word != ''">
                                        <td class="wordhere" x-text="word"></td>
                                        <template x-for="(exists, index) in node.matrix[index]">
                                            <td class="pickercol" :class="node.colors[index] + (hindex == index ? ' hovering' : '')" @click.stop="selectLetter(node, index)" @mouseenter="hindex = index" @mouseleave="hindex = -1">
                                                <template x-if="exists"><span>X</span></template>
                                            </td>
                                        </template>
                                        <template x-if="node.deadEnd && index === 0">
                                            <td :rowspan="node.words.length" style="vertical-align: middle;background-color: #800;color: #fbc;">
                                                <strong>DEAD END</strong>
                                            </td>
                                        </template>
                                    </tr>
                                </template>
                                </tbody>
                            </table>
                        </td>
                    </template>
                </tr>
            </template>
        </tbody>
    </table>
    <div class="no-print">
        <br>
        Permalink:
        <br>
        <a :href="permaLink" x-text="permaLink"></a>
    </div>
    <script>
        const splitPointsLookup = {}
        let wordsKeyed = {}
        class TNode {
            constructor(words, level, css) {
                this.css = css
                this.yesNode = null
                this.noNode = null
                this.chosenLetter = null
                this.words = words
                this.matrix = []
                this.sums = []
                this.colors = []
                this.level = level
                this.breadth = 1
                this.deadEnd = false
            }
        }
        document.addEventListener('alpine:init', () => {
            Alpine.data('main', () => ({
                // wordBox: "test\ndata\nfoo\nwoo\nhappy\ncoal",
                wordBox: "",
                listLength: 1,
                lastBoxCalculated: "",
                lastCalculated: [],
                letters: [...Array(26).keys()].map(i => String.fromCharCode('A'.charCodeAt(0) + i)),
                levels: [],
                dupes: [],
                gridList: [],
                isVertical: true,
                nosFirst: true,
                hideBad: true,
                startNode: new TNode([], 0),
                init () {
                    for (let i = 1; i <= 128; i++) {
                        const minbest = Math.floor(i / 2)
                        const maxbest = Math.ceil(i / 2)
                        const minsplit = Math.pow(2, (Math.ceil(Math.log2(i)) - 1))
                        splitPointsLookup[i] = [minbest, maxbest, minsplit]
                    }
                    const urlParams = new URLSearchParams(window.location.search)
                    this.wordBox = urlParams.get('words') ?? ""
                    this.changeWordBox()
                    this.recalcTree()
                    const picks = urlParams.get('picks')
                    if (picks && picks.toUpperCase().replace(/[^A-Z.]/g, '').length > 0) {
                        const pickPieces = picks.toUpperCase().replace(/[^A-Z.]/g, '').split('')
                        this.deserializePicks(this.startNode, pickPieces)
                    }
                    this.$watch('nosFirst', () => this.recalcTree())
                },
                deserializePicks(node, picked) {
                    if (picked.length === 0 || node.words.length < 2) {
                        return
                    }
                    const chosenLetter = picked.shift()
                    if (chosenLetter === "." || !this.letters.includes(chosenLetter)) {
                        return
                    }
                    const chosenIndex = this.letters.indexOf(chosenLetter)
                    this.selectLetter(node, chosenIndex)
                    this.deserializePicks(node.noNode, picked)
                    this.deserializePicks(node.yesNode, picked)
                },
                serializePicks(node, picks) {
                    if (!node || node.words.length < 2) {
                        return
                    }
                    if (!node.chosenLetter) {
                        picks.push('.')
                        return
                    }
                    picks.push(node.chosenLetter)
                    this.serializePicks(node.noNode, picks)
                    this.serializePicks(node.yesNode, picks)
                },
                changeWordBox() {
                    const words = this.wordBox.replace(/,/g,"\n").split("\n").map(word => ({ orig: word.trim(), check: word.toUpperCase().replace(/[^A-Z]/g, '') })).filter(word => word.check)
                    this.listLength = this.wordBox.replace(/[^\n]/g,'').length + 2
                    const crammedWord = words.map(word => word.check).join(",")
                    if (crammedWord !== this.lastBoxCalculated) {
                        wordsKeyed = {}
                        words.forEach(word => {
                            wordsKeyed[word.orig] = Array.from(new Set(word.check.split(''))).sort().join('')
                        })
                        this.lastBoxCalculated = crammedWord
                        this.startNode = new TNode(words.map(word => word.orig), 0)
                        this.checkDeadEnds()
                        this.calcSums(this.startNode)
                        this.deselectLetter(this.startNode)
                        this.recalcTree()
                    }
                },
                checkDeadEnds() {
                    const checkers = this.startNode.words.map(word => ({ orig: word, letters: wordsKeyed[word] })).sort(({ letters: a }, { letters: b}) => a < b ? -1 : a > b ? 1 : 0)
                    const seen = new Set()
                    const dupeSet = new Set()
                    this.dupes = [];
                    checkers.forEach(({letters, orig}) => {
                        if (seen.has(letters)) {
                            dupeSet.add(letters)
                        } else {
                            seen.add(letters)
                        }
                    })
                    dupeSet.forEach(letters => {
                        this.dupes.push(checkers.filter(word => word.letters === letters).map(word => word.orig))
                    })
                },
                calcSums(node, recurse) {
                    node.matrix = node.words.map(word => this.letters.map(c => wordsKeyed[word].includes(c) ? 1 : 0))
                    if (node.words.length > 0) {
                        node.sums = node.matrix.reduce((prev, curr) => {
                            return curr.map((v, idx) => {
                                return v + prev[idx]
                            })
                        })
                    }
                    const len = node.words.length
                    let minbest, maxbest, minsplit
                    const precalcSplits = splitPointsLookup[len]
                    if (precalcSplits !== undefined) {
                        [minbest, maxbest, minsplit] = precalcSplits
                    } else {
                        // fallback if a user enters more than 128 words.
                        minbest = Math.floor(len / 2)
                        maxbest = Math.ceil(len / 2)
                        minsplit = Math.pow(2, (Math.ceil(Math.log2(len)) - 1))
                    }
                    node.deadEnd = true
                    node.colors = node.sums.map(v => {
                        let color = ""
                        if (v === 0 || v === len) {
                            color = "hidecol"
                        } else if (v > minsplit || v < (len - minsplit)) {
                            if (this.hideBad) {
                                color = "hidecol"
                            } else {
                                color = "warning"
                            }
                        } else if (v >= minbest && v <= maxbest) {
                            color = "best"
                        }
                        if (color !== "hidecol") {
                            node.deadEnd = false
                        }
                        return color
                    })
                    if (recurse) {
                        if (node.yesNode) {
                            this.calcSums(node.yesNode, true)
                        }
                        if (node.noNode) {
                            this.calcSums(node.noNode, true)
                        }
                    }
                },
                selectLetter(node, letterIndex) {
                    const yesWords = node.words.filter((word, wordIndex) => node.matrix[wordIndex][letterIndex])
                    const noWords = node.words.filter((word, wordIndex) => !node.matrix[wordIndex][letterIndex])
                    node.yesNode = new TNode(yesWords, node.level + 1, 'yesnode')
                    node.noNode = new TNode(noWords, node.level + 1, 'nonode')
                    node.chosenLetter = this.letters[letterIndex]
                    this.calcSums(node.yesNode)
                    this.calcSums(node.noNode)
                    this.recalcTree()
                },
                deselectLetter(node) {
                    if (!node || !node.chosenLetter) {
                        return
                    }
                    node.chosenLetter = null
                    node.noNode = null
                    node.yesNode = null
                    this.recalcTree()
                },
                recalcTree() {
                    this.levelCount = 0
                    this.levels = []
                    this.gridList = []
                    this.calcGridDimensions(this.startNode)
                    this.setBreadth(this.startNode)
                },
                calcGridDimensions(node) {
                    if (!node) {
                        return 0
                    }
                    if (!this.levels[node.level]) {
                        this.levelCount = Math.max(this.levelCount, node.level + 1)
                        this.levels[node.level] = []
                    }
                    this.levels[node.level].push(node)
                    this.gridList.push(node)
                    if (node.chosenLetter) {
                        let noLeaves, yesLeaves
                        if (this.nosFirst) {
                            noLeaves = this.calcGridDimensions(node.noNode)
                            yesLeaves = this.calcGridDimensions(node.yesNode)
                        } else {
                            yesLeaves = this.calcGridDimensions(node.yesNode)
                            noLeaves = this.calcGridDimensions(node.noNode)
                        }
                        node.leaves = noLeaves + yesLeaves
                    } else {
                        node.leaves = 1
                    }
                    return node.leaves
                },
                setBreadth(node) {
                    if (!node) {
                        return
                    }
                    node.breadth = node.chosenLetter ? 1 : this.levelCount - node.level
                    this.setBreadth(node.noNode)
                    this.setBreadth(node.yesNode)
                },
                permaLink() {
                    const url = new URL(window.location)
                    const params = new URLSearchParams(url.search)
                    const words = this.wordBox.replace(/,/g,"\n").split("\n").map(word => word.trim()).join(",")
                    if (words.length > 0) {
                        params.set('words', this.wordBox.replace(/,/g,"\n").split("\n").map(word => word.trim()).filter(v => v).join("\n"))
                    } else {
                        params.delete('words')
                    }
                    const picks = []
                    this.serializePicks(this.startNode, picks)
                    const pickString = picks.join('').replace(/\.*$/,'')
                    if (pickString.length > 0) {
                        params.set('picks', pickString)
                    } else {
                        params.delete('picks')
                    }
                    url.search = params.toString()
                    return url.href
                }
            }))
        })
    </script>
</body>
</html>
